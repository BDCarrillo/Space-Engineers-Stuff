//Original: https://steamcommunity.com/sharedfiles/filedetails/?id=1542976322

// Follower Script Version 1.2

// ============= Settings ==============
// Settings are located entirely in Custom Data.
// Run the script once to generate an initial config.
// =====================================

// ============= Commands ==============
// setoffset;x;y;z : sets the offset variable to this value
// addoffset;x;y;z : adds these values to the current offset
// stop : stops the script and releases control to you
// start : starts the script after a stop command
// starthere : starts the script in the current position
// clear : forces the script to forget a previous leader when calculateMissingTicks is true
// reset : loads the current configuration, or the first offset
// save(;name) : saves the configuration to the current offset
// savehere(;name) : saves the configuration to the current position
// load;name : loads the offset from the configuration
// =====================================

StorageData storage;
Settings settings;

IMyShipController rc;
ThrusterControl thrust;
GyroControl gyros;
List<IMyCameraBlock> cameras = new List<IMyCameraBlock>();
Vector3D? obstacleOffset = null;
MatrixD leaderMatrix = MatrixD.Zero;
Vector3D leaderVelocity;
Random r = new Random();
IMyBroadcastListener leaderListener;
IMyBroadcastListener commandListener;
readonly string transmitTag = "FSLeader";
readonly string transmitCommandTag = "FSCommand";

readonly int echoFrequency = 100; // every 100th game tick
int runtime = 0;
int updated = 0;

bool prevControl = false;

public Program ()
{
    settings = new Settings(Me);
    settings.Load();

    storage = new StorageData(this);
    storage.Load();

    transmitTag += settings.followerSystemId.Value;
    transmitCommandTag += settings.followerSystemId.Value;

    // Prioritize the given cockpit name
    rc = GetBlock<IMyShipController>(settings.cockpitName.Value, true);
    if (rc == null) // Second priority cockpit
        rc = GetBlock<IMyCockpit>();
    if (rc == null) // Third priority remote control
        rc = GetBlock<IMyRemoteControl>();
    if (rc == null) // No cockpits found.
        throw new Exception("No cockpit/remote control found. Set the cockpitName field in settings.");

    thrust = new ThrusterControl(rc, settings.tickSpeed.Value, GetBlocks<IMyThrust>());
    gyros = new GyroControl(rc, settings.tickSpeed.Value, GetBlocks<IMyGyro>());

    if (settings.enableCollisionAvoidence.Value)
        cameras = GetBlocks<IMyCameraBlock>();

    if (settings.tickSpeed.Value == UpdateFrequency.Update10)
        echoFrequency = 10;
    else if (settings.tickSpeed.Value == UpdateFrequency.Update100)
        echoFrequency = 1;

    leaderListener = IGC.RegisterBroadcastListener(transmitTag);
    leaderListener.SetMessageCallback("");
    commandListener = IGC.RegisterBroadcastListener(transmitCommandTag);
    commandListener.SetMessageCallback("");

    Echo("Ready.");
    if (!storage.IsDisabled)
        Runtime.UpdateFrequency = settings.tickSpeed.Value;
}

void ResetMovement()
{
    gyros.Reset();
    thrust.Reset();
}

public void Main (string argument, UpdateType updateSource)
{
    if (updateSource == UpdateType.Update100 || updateSource == UpdateType.Update10 || updateSource == UpdateType.Update1)
    {
        if (runtime % echoFrequency == 0)
            WriteEcho();

        // Check to make sure that a message from the leader has been received
        if (leaderMatrix == MatrixD.Zero)
        {
            runtime++;
            return;
        }

        if (settings.autoStop.Value)
        {
            bool control = rc.IsUnderControl;
            if (control != prevControl)
            {
                if (control)
                    ResetMovement();
                else if (settings.autoStartHere.Value)
                    storage.Offset = CurrentOffset();

                prevControl = control;
            }

            if (prevControl)
            {
                runtime++;
                return;
            }
        }

        Move();
        runtime++;
    }
    else if (updateSource == UpdateType.IGC)
    {
        if (leaderListener.HasPendingMessage)
        {
            var data = leaderListener.AcceptMessage().Data;
            if (data is MyTuple<MatrixD, Vector3D, long>)
            {
                MyTuple<MatrixD, Vector3D, long> msg = (MyTuple<MatrixD, Vector3D, long>)data;
                if (msg.Item3 != Me.CubeGrid.EntityId)
                {
                    leaderMatrix = msg.Item1;
                    leaderVelocity = msg.Item2;
                    updated = runtime;
                }
                else
                {
                    leaderMatrix = MatrixD.Zero;
                }
            }
            else if (data is MyTuple<MatrixD, Vector3D>)
            {
                MyTuple<MatrixD, Vector3D> msg = (MyTuple<MatrixD, Vector3D>)data;
                leaderMatrix = msg.Item1;
                leaderVelocity = msg.Item2;
                updated = runtime;
            }
        }

        if (commandListener.HasPendingMessage)
        {
            var data = commandListener.AcceptMessage().Data;
            if (data is MyTuple<string, string>)
            {
                MyTuple<string, string> msg = (MyTuple<string, string>)data;

                if (msg.Item1.Length > 0)
                {
                    foreach (string s in msg.Item1.Split(';'))
                    {
                        if (s == settings.followerId.Value)
                        {
                            RemoteCommand(msg.Item2);
                            return;
                        }
                    }
                    return;
                }
                else
                {
                    RemoteCommand(msg.Item2);
                    return;
                }
            }
        }
    }
    else
    {
        RemoteCommand(argument);
    }
}

void WriteEcho()
{
    StringBuilder sb = new StringBuilder();
    sb.AppendLine("Running.");
    sb.Append(settings.followerSystemId).Append('.').Append(settings.followerId).AppendLine();
    Vector3D offset = storage.Offset;
    sb.AppendLine(offset.ToString("0.00"));
    if (offset == Vector3D.Zero)
    {
        sb.AppendLine("Offset is zero,");
        sb.AppendLine("Use commands to give the offset a value.");
    }
    if (leaderMatrix == MatrixD.Zero)
        sb.AppendLine("No messages received.");
    else if (settings.calculateMissingTicks.Value && runtime - updated > settings.maxMissingScriptTicks.Value)
        sb.AppendLine($"Weak signal, message received {runtime - updated} ticks ago.");
    if (settings.autoStop.Value && prevControl)
        sb.AppendLine("Cockpit is under control.");
    if (obstacleOffset.HasValue)
        sb.AppendLine("Obstacle Detected! Stopping the ship.");
    sb.AppendLine();
    sb.AppendLine("Configs:");
    foreach (string s in settings.configs.Value.Keys)
    {
        sb.Append(' ').Append(s);
        if (s == storage.CurrentConfig)
            sb.Append('*');
        sb.AppendLine();
    }

    Echo(sb.ToString());
}


void Move ()
{
    gyros.FaceVectors(leaderMatrix.Forward, leaderMatrix.Up);

    Vector3D offset = storage.Offset;
    if (offset == Vector3D.Zero)
    {
        thrust.ApplyAccel(thrust.ControlVelocity(leaderVelocity));
        return;
    }

    // Apply translations to find the world position that this follower is supposed to be
    Vector3D targetPosition = Vector3D.Transform(offset, leaderMatrix);

    if (settings.calculateMissingTicks.Value)
    {
        int diff = Math.Min(Math.Abs(runtime - updated), settings.maxMissingScriptTicks.Value);
        if (diff > 0)
        {
            double secPerTick = 1.0 / 60;
            if (settings.tickSpeed.Value == UpdateFrequency.Update10)
                secPerTick = 1.0 / 6;
            else if (settings.tickSpeed.Value == UpdateFrequency.Update100)
                secPerTick = 5.0 / 3;
            double secPassed = diff * secPerTick;
            targetPosition += leaderVelocity * secPassed;
        }
    }

    if (settings.enableCollisionAvoidence.Value)
    {
        CheckForCollistions(targetPosition);
        if (obstacleOffset.HasValue)
        {
            thrust.ApplyAccel(thrust.ControlPosition(Vector3D.Transform(obstacleOffset.Value, leaderMatrix), leaderVelocity, settings.maxSpeed.Value));
            return;
        }
    }

    thrust.ApplyAccel(thrust.ControlPosition(targetPosition, leaderVelocity, settings.maxSpeed.Value));
}

void RemoteCommand (string command)
{
    string [] args = command.Split(';');

    switch (args [0])
    {
        case "setoffset": // setoffset;x;y;z
            if (args.Length == 4)
            {
                Vector3D offset = storage.Offset;
                double temp;
                if (!string.IsNullOrWhiteSpace(args[1]) && double.TryParse(args[1], out temp))
                    offset.X = temp;
                if (!string.IsNullOrWhiteSpace(args[2]) && double.TryParse(args[2], out temp))
                    offset.Y = temp;
                if (!string.IsNullOrWhiteSpace(args[3]) && double.TryParse(args[3], out temp))
                    offset.Z = temp;

                storage.Offset = offset;
                WriteEcho();
            }
            else
            {
                return;
            }
            break;
        case "addoffset": // addoffset;x;y;z
            if (args.Length == 4)
            {
                Vector3D offset = new Vector3D();
                double temp;
                if (!string.IsNullOrWhiteSpace(args[1]) && double.TryParse(args[1], out temp))
                    offset.X = temp;
                if (!string.IsNullOrWhiteSpace(args[2]) && double.TryParse(args[2], out temp))
                    offset.Y = temp;
                if (!string.IsNullOrWhiteSpace(args[3]) && double.TryParse(args[3], out temp))
                    offset.Z = temp;

                storage.Offset += offset;
                WriteEcho();
            }
            else
            {
                return;
            }
            break;
        case "stop": // stop
            Runtime.UpdateFrequency = UpdateFrequency.None;
            ResetMovement();
            storage.IsDisabled = true;
            Echo("Stopped.");
            break;
        case "start": // start
            Runtime.UpdateFrequency = settings.tickSpeed.Value;
            storage.IsDisabled = false;
            WriteEcho();
            break;
        case "starthere": // starthere
            Runtime.UpdateFrequency = settings.tickSpeed.Value;
            storage.AutoSave = false;
            storage.Offset = CurrentOffset();
            storage.IsDisabled = false;
            storage.Save();
            WriteEcho();
            break;
        case "reset": // reset
            {
                Vector3D newOffset;
                if (!settings.configs.Value.TryGetValue(storage.CurrentConfig, out newOffset))
                    newOffset = settings.configs.Value.First().Value;
                storage.Offset = newOffset;
                WriteEcho();
            }
            break;
        case "save": // save(;name)
            {
                string key = storage.CurrentConfig;
                if (args.Length > 1)
                    key = args [1];

                if (key.Contains(' '))
                    return;

                settings.configs.Value [key] = storage.Offset;
                settings.Save();
            }
            break;
        case "savehere": // save(;name)
            {
                string key = storage.CurrentConfig;
                if (args.Length > 1)
                    key = args [1];

                if (key.Contains(' '))
                    return;

                Vector3D newOffset = CurrentOffset();
                settings.configs.Value [key] = newOffset;
                settings.Save();
            }
            break;
        case "load": // load;name
            {
                Vector3D newOffset;
                if (args.Length == 1 || !settings.configs.Value.TryGetValue(args[1], out newOffset))
                    return;
                // Load the new config
                storage.AutoSave = false;
                storage.Offset = newOffset;
                storage.CurrentConfig = args [1];
                storage.IsDisabled = false;
                storage.Save();
                WriteEcho();
            }
            break;
        case "clear":
            leaderMatrix = MatrixD.Zero;
            break;
    }
}

Vector3D CurrentOffset ()
{
    return Vector3D.TransformNormal(rc.GetPosition() - leaderMatrix.Translation, MatrixD.Transpose(rc.WorldMatrix));
}

bool StringToVector (string x, string y, string z, out Vector3D output)
{
    try
    {
        double x2 = double.Parse(x);
        double y2 = double.Parse(y);
        double z2 = double.Parse(z);
        output = new Vector3D(x2, y2, z2);
        return true;
    }
    catch (Exception)
    {
        output = new Vector3D();
        return false;
    }
}

void CheckForCollistions (Vector3D target)
{
    double resultDist;
    if (!Raycast(target, out resultDist))
    {
        return;
    }

    if (double.IsInfinity(resultDist))
    {
        obstacleOffset = null;
        return;
    }

    obstacleOffset = CurrentOffset();
}

bool Raycast (Vector3D target, out double hitDistance)
{
    bool raycasted = false;
    hitDistance = double.PositiveInfinity;
    foreach (IMyCameraBlock c in cameras)
    {
        c.Enabled = true;
        c.EnableRaycast = true;
        if (c.CanScan(target))
        {
            raycasted = true;
            MyDetectedEntityInfo info = c.Raycast(target);
            if (info.HitPosition.HasValue)
            {
                if (info.EntityId == Me.CubeGrid.EntityId)
                    continue;

                double dist = Vector3D.Distance(c.GetPosition(), info.HitPosition.Value);
                if (dist < hitDistance && dist > 0.1)
                {
                    hitDistance = dist;
                }

            }
        }
    }
    return raycasted;
}

T GetBlock<T> (string name, bool useSubgrids = false) where T : class, IMyTerminalBlock
{
    if (useSubgrids)
    {
        return GridTerminalSystem.GetBlockWithName(name) as T;
    }
    else
    {
        List<T> blocks = GetBlocks<T>(false);
        foreach (T block in blocks)
        {
            if (block.CustomName == name)
                return block;
        }
        return null;
    }
}
T GetBlock<T> (bool useSubgrids = false) where T : class, IMyTerminalBlock
{
    List<T> blocks = GetBlocks<T>(useSubgrids);
    return blocks.FirstOrDefault();
}
List<T> GetBlocks<T> (string groupName, bool useSubgrids = false) where T : class, IMyTerminalBlock
{
    IMyBlockGroup group = GridTerminalSystem.GetBlockGroupWithName(groupName);
    if (group == null)
        return new List<T>();
    List<T> blocks = new List<T>();
    if (useSubgrids)
        group.GetBlocksOfType(blocks);
    else
        group.GetBlocksOfType(blocks, b => b.CubeGrid.EntityId == Me.CubeGrid.EntityId);
    return blocks;

}
List<T> GetBlocks<T> (bool useSubgrids = false) where T : class, IMyTerminalBlock
{
    List<T> blocks = new List<T>();
    if (useSubgrids)
        GridTerminalSystem.GetBlocksOfType(blocks);
    else
        GridTerminalSystem.GetBlocksOfType(blocks, b => b.CubeGrid.EntityId == Me.CubeGrid.EntityId);
    return blocks;
}

const double gyroP = 18;
const double gyroI = 0;
const double gyroD = 3;
const double gyroMax = 1000;

class GyroControl
{
    private List<IMyGyro> gyros;
    IMyCubeBlock rc;

    public GyroControl (IMyCubeBlock rc, UpdateFrequency tickSpeed, List<IMyGyro> gyros)
    {
        if (rc == null)
            throw new Exception("Reference block null.");

        this.rc = rc;

        this.gyros = gyros;

        double factor = 1;
        if (tickSpeed == UpdateFrequency.Update10)
            factor = 10;
        else if (tickSpeed == UpdateFrequency.Update100)
            factor = 100;
        double secondsPerTick = (1.0 / 60) * factor;
        anglePID = new VectorPID(gyroP / factor, gyroI / factor, gyroD / factor, -gyroMax, gyroMax, secondsPerTick);

        Reset();
    }
    // In (pitch, yaw, roll)
    VectorPID anglePID;

    public void Reset ()
    {
        for (int i = 0; i < gyros.Count; i++)
        {
            IMyGyro g = gyros [i];
            if (g == null)
            {
                gyros.RemoveAtFast(i);
                continue;
            }
            g.GyroOverride = false;
        }
        anglePID.Reset();
    }

    /// <summary>
            /// Prioritizes up vector.
            /// </summary>
    Vector3D GetAngles2 (MatrixD current, Vector3D forward, Vector3D up)
    {
        Vector3D error = new Vector3D();

        // yaw
        if (forward != Vector3D.Zero)
        {
            Vector3D temp = Vector3D.Normalize(VectorRejection(forward, current.Up));
            double dot = MathHelper.Clamp(Vector3D.Dot(current.Forward, temp), -1, 1);
            double yawAngle = Math.Acos(dot);
            double scaler = ScalerProjection(temp, current.Right);
            if (scaler > 0)
                yawAngle *= -1;
            error.Y = yawAngle;
        }

        // pitch and roll
        if (up != Vector3D.Zero)
        {
            Quaternion quat = Quaternion.CreateFromForwardUp(current.Up, current.Forward);
            Quaternion invQuat = Quaternion.Inverse(quat);
            Vector3D RCReferenceFrameVector = Vector3D.Transform(up, invQuat);
            Vector3D.GetAzimuthAndElevation(RCReferenceFrameVector, out error.Z, out error.X);
            error.Z *= -1;
            error.X *= -1;
        }

        if (Math.Abs(error.X) < 0.001)
            error.X = 0;
        if (Math.Abs(error.Y) < 0.001)
            error.Y = 0;
        if (Math.Abs(error.Z) < 0.001)
            error.Z = 0;

        return error;
    }

    /// <summary>
            /// Prioritizes forward vector.
            /// </summary>
    Vector3D GetAngles (MatrixD current, Vector3D forward, Vector3D up)
    {
        Vector3D error = new Vector3D();

        if (forward != Vector3D.Zero)
        {
            Quaternion quat = Quaternion.CreateFromForwardUp(current.Forward, current.Up);
            Quaternion invQuat = Quaternion.Inverse(quat);
            Vector3D RCReferenceFrameVector = Vector3D.Transform(forward, invQuat);
            Vector3D.GetAzimuthAndElevation(RCReferenceFrameVector, out error.Y, out error.X);
        }

        if (up != Vector3D.Zero)
        {
            Vector3D temp = Vector3D.Normalize(VectorRejection(up, current.Forward));
            double dot = MathHelper.Clamp(Vector3D.Dot(current.Up, temp), -1, 1);
            double rollAngle = Math.Acos(dot);
            double scaler = ScalerProjection(temp, current.Right);
            if (scaler > 0)
                rollAngle *= -1;
            error.Z = rollAngle;
        }

        if (Math.Abs(error.X) < 0.001)
            error.X = 0;
        if (Math.Abs(error.Y) < 0.001)
            error.Y = 0;
        if (Math.Abs(error.Z) < 0.001)
            error.Z = 0;

        return error;
    }
    /// <summary>
            /// Prioritizes up vector.
            /// </summary>
    public void FaceVectors2 (Vector3D forward, Vector3D up)
    {
        // In (pitch, yaw, roll)
        Vector3D error = -GetAngles2(rc.WorldMatrix, forward, up);
        Vector3D angles = new Vector3D(anglePID.Control(error));
        ApplyGyroOverride(rc.WorldMatrix, angles);
    }
    /// <summary>
            /// Prioritizes forward vector.
            /// </summary>
    public void FaceVectors (Vector3D forward, Vector3D up)
    {
        // In (pitch, yaw, roll)
        Vector3D error = -GetAngles(rc.WorldMatrix, forward, up);
        Vector3D angles = new Vector3D(anglePID.Control(error));
        ApplyGyroOverride(rc.WorldMatrix, angles);
    }
    void ApplyGyroOverride (MatrixD current, Vector3D localAngles)
    {
        Vector3D worldAngles = Vector3D.TransformNormal(localAngles, current);
        foreach (IMyGyro gyro in gyros)
        {
            Vector3D transVect = Vector3D.TransformNormal(worldAngles, MatrixD.Transpose(gyro.WorldMatrix));  //Converts To Gyro Local
            if (!transVect.IsValid())
                throw new Exception("Invalid trans vector. " + transVect.ToString());

            gyro.Pitch = (float)transVect.X;
            gyro.Yaw = (float)transVect.Y;
            gyro.Roll = (float)transVect.Z;
            gyro.GyroOverride = true;
        }
    }

    /// <summary>
            /// Projects a value onto another vector.
            /// </summary>
            /// <param name="guide">Must be of length 1.</param>
    public static double ScalerProjection (Vector3D value, Vector3D guide)
    {
        double returnValue = Vector3D.Dot(value, guide);
        if (double.IsNaN(returnValue))
            return 0;
        return returnValue;
    }

    /// <summary>
            /// Projects a value onto another vector.
            /// </summary>
            /// <param name="guide">Must be of length 1.</param>
    public static Vector3D VectorPojection (Vector3D value, Vector3D guide)
    {
        return ScalerProjection(value, guide) * guide;
    }

    /// <summary>
            /// Projects a value onto another vector.
            /// </summary>
            /// <param name="guide">Must be of length 1.</param>
    public static Vector3D VectorRejection (Vector3D value, Vector3D guide)
    {
        return value - VectorPojection(value, guide);
    }
}

public abstract class IniValue<T>
{
    private readonly string comment;
    protected readonly MyIniKey key;
    public IniValue(string section, string key, T defaultValue = default(T), string comment = null)
    {
        this.key = new MyIniKey(section, key);
        value = defaultValue;
        this.comment = comment;
    }

    protected T value;
    public T Value
    {
        get
        {
            return value;
        }
    }

    public void Load (MyIni ini)
    {
        if (!TryGetValue(ini.Get(key), out value))
            throw new IniMissingException(key.Name);
    }

    public void Save (MyIni ini)
    {
        Set(ini);
        ini.SetComment(key, comment);
    }

    protected abstract void Set(MyIni ini);

    protected abstract bool TryGetValue (MyIniValue storage, out T value);

    public override string ToString ()
    {
        return value.ToString();
    }

    public override bool Equals (object obj)
    {
        IniValue<T> value = obj as IniValue<T>;
        return value != null &&
               EqualityComparer<T>.Default.Equals(this.value, value.value);
    }

    public override int GetHashCode ()
    {
        return -1584136870 + EqualityComparer<T>.Default.GetHashCode(value);
    }
}

public class IniValueBool : IniValue<bool>
{
    public IniValueBool (string section, string key, bool defaultValue = false, string comment = null) : base(section, key, defaultValue, comment) { }
    protected override void Set (MyIni ini)
    {
        ini.Set(key, value);
    }
    protected override bool TryGetValue (MyIniValue storage, out bool value)
    {
        return storage.TryGetBoolean(out value);
    }
}

public class IniValueString : IniValue<string>
{
    public IniValueString (string section, string key, string defaultValue = null, string comment = null) : base(section, key, defaultValue, comment) { }
    protected override void Set (MyIni ini)
    {
        ini.Set(key, value);
    }
    protected override bool TryGetValue (MyIniValue storage, out string value)
    {
        return storage.TryGetString(out value);
    }
}

public class IniValueVector3D : IniValue<Vector3D>
{
    public IniValueVector3D (string section, string key, Vector3D defaultValue = default(Vector3D), string comment = null) : base(section, key, defaultValue, comment) { }
    protected override void Set (MyIni ini)
    {
        ini.Set(key, $"{value.X} {value.Y} {value.Z}");
    }
    protected override bool TryGetValue (MyIniValue storage, out Vector3D value)
    {
        value = new Vector3D();
        string temp;
        if (!storage.TryGetString(out temp))
            return false;
        string [] args = temp.Split(new [] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
        if (args.Length != 3)
            return false;
        if (!double.TryParse(args [0], out value.X))
            return false;
        if (!double.TryParse(args [1], out value.Y))
            return false;
        return double.TryParse(args [2], out value.Z);
    }
}

public class IniValueEnum<T> : IniValue<T> where T : struct, IComparable
{
    public IniValueEnum (string section, string key, T defaultValue = default(T), string comment = null) : base(section, key, defaultValue, comment) { }
    protected override void Set (MyIni ini)
    {
        ini.Set(key, value.ToString());
    }

    protected override bool TryGetValue (MyIniValue storage, out T value)
    {
        value = default(T);
        string temp;
        if (!storage.TryGetString(out temp))
            return false;
        return Enum.TryParse<T>(temp, out value);
    }
}

public class IniValueInt : IniValue<int>
{
    public IniValueInt (string section, string key, int defaultValue = 0, string comment = null) : base(section, key, defaultValue, comment) { }
    protected override void Set (MyIni ini)
    {
        ini.Set(key, value);
    }
    protected override bool TryGetValue (MyIniValue storage, out int value)
    {
        return storage.TryGetInt32(out value);
    }
}

public class IniValueDouble : IniValue<double>
{
    public IniValueDouble (string section, string key, double defaultValue = 0, string comment = null) : base(section, key, defaultValue, comment) { }

    protected override void Set (MyIni ini)
    {
        ini.Set(key, value);
    }

    protected override bool TryGetValue (MyIniValue storage, out double value)
    {
        return storage.TryGetDouble(out value);
    }
}

public class IniMissingException : IniParseException
{
    public IniMissingException (string id)
        : base("Value for '" + id + "' is missing or invalid")
    {
    }

    public IniMissingException (string id, Exception innerException)
        : base("Value for '" + id + "' is missing or invalid", innerException)
    {
    }
}

public class IniParseException : Exception
{
    private const string error = "Failed to parse CustomData settings.\n";
    public IniParseException () : base(error)
    {
    }

    public IniParseException (string message) : base(error + message)
    {
    }

    public IniParseException (string message, Exception innerException) : base(error + message, innerException)
    {
    }
}

//Whip's PID controller class v6 - 11/22/17
public class PID
{
    double _kP = 0;
    double _kI = 0;
    double _kD = 0;
    double _integralDecayRatio = 0;
    double _lowerBound = 0;
    double _upperBound = 0;
    double _timeStep = 0;
    double _inverseTimeStep = 0;
    double _errorSum = 0;
    double _lastError = 0;
    bool _firstRun = true;
    bool _integralDecay = false;
    public double Value
    {
        get; private set;
    }

    public PID (double kP, double kI, double kD, double lowerBound, double upperBound, double timeStep)
    {
        _kP = kP;
        _kI = kI;
        _kD = kD;
        _lowerBound = lowerBound;
        _upperBound = upperBound;
        _timeStep = timeStep;
        _inverseTimeStep = 1 / _timeStep;
        _integralDecay = false;
    }

    public PID (double kP, double kI, double kD, double integralDecayRatio, double timeStep)
    {
        _kP = kP;
        _kI = kI;
        _kD = kD;
        _timeStep = timeStep;
        _inverseTimeStep = 1 / _timeStep;
        _integralDecayRatio = integralDecayRatio;
        _integralDecay = true;
    }

    public double Control (double error)
    {
        //Compute derivative term
        var errorDerivative = (error - _lastError) * _inverseTimeStep;

        if (_firstRun)
        {
            errorDerivative = 0;
            _firstRun = false;
        }

        //Compute integral term
        if (!_integralDecay)
        {
            _errorSum += error * _timeStep;

            //Clamp integral term
            if (_errorSum > _upperBound)
                _errorSum = _upperBound;
            else if (_errorSum < _lowerBound)
                _errorSum = _lowerBound;
        }
        else
        {
            _errorSum = _errorSum * (1.0 - _integralDecayRatio) + error * _timeStep;
        }

        //Store this error as last error
        _lastError = error;

        //Construct output
        this.Value = _kP * error + _kI * _errorSum + _kD * errorDerivative;
        return this.Value;
    }

    public double Control (double error, double timeStep)
    {
        _timeStep = timeStep;
        _inverseTimeStep = 1 / _timeStep;
        return Control(error);
    }

    public void Reset ()
    {
        _errorSum = 0;
        _lastError = 0;
        _firstRun = true;
    }
}

public class VectorPID
{
    private PID X;
    private PID Y;
    private PID Z;

    public VectorPID (double kP, double kI, double kD, double lowerBound, double upperBound, double timeStep)
    {
        X = new PID(kP, kI, kD, lowerBound, upperBound, timeStep);
        Y = new PID(kP, kI, kD, lowerBound, upperBound, timeStep);
        Z = new PID(kP, kI, kD, lowerBound, upperBound, timeStep);
    }

    public VectorPID (double kP, double kI, double kD, double integralDecayRatio, double timeStep)
    {
        X = new PID(kP, kI, kD, integralDecayRatio, timeStep);
        Y = new PID(kP, kI, kD, integralDecayRatio, timeStep);
        Z = new PID(kP, kI, kD, integralDecayRatio, timeStep);
    }

    public Vector3D Control (Vector3D error)
    {
        return new Vector3D(X.Control(error.X), Y.Control(error.Y), Z.Control(error.Z));
    }

    public void Reset ()
    {
        X.Reset();
        Y.Reset();
        Z.Reset();
    }
}

public class Settings
{
    private readonly IMyProgrammableBlock Me;
    private readonly MyIni ini = new MyIni();
    private const string section = "FormationSystem-Follower";
    private bool init = false;

    public IniValueString followerSystemId = new IniValueString(section, "followerSystemId", "System1",
        "\n The id that the ship should listen to." +
        "\n All commands not prefixed by this will be ignored.");
    public IniValueString followerId = new IniValueString(section, "followerId", "Drone1");
    public IniValueConfigs configs = new IniValueConfigs(section, "configs",
        "\n Configurations:" +
        "\n Use this to store a list of offsets. There must be at least one config." +
        "\n You can use commands to edit this or you can edit directly and" +
        "\n recompile. Each line stores an offset and a tag for that offset." +
        "\n Format: \"|Name X Y Z\"" +
        "\n X: +Right -Left" +
        "\n Y: +Up -Down" +
        "\n Z: +Backward -Forward");
    public IniValueBool enableCollisionAvoidence = new IniValueBool(section, "enableCollisionAvoidence", false,
        "\n When enabled, the script will attempt to avoid collisions by stopping" +
        "\n when there is something between itself and its designated position." +
        "\n This is a CPU intensive process!");
    public IniValueString cockpitName = new IniValueString(section, "cockpitName", "Cockpit",
        "\n The name of the cockpit in the ship.If this cockpit is not" +
        "\n found, the script will attempt to find one on its own.");
    public IniValueBool autoStop = new IniValueBool(section, "autoStop", true,
        "\n When true, the script will not run if there is a player" +
        "\n in the designated cockpit.");
    public IniValueBool autoStartHere = new IniValueBool(section, "autoStartHere", false,
        "\n When true, upon leaving the cockpit, the script will set the offset to" +
        "\n the current position instead of returning to its designated point." +
        "\n This is equivalent to the starthere command.");
    public IniValueDouble maxSpeed = new IniValueDouble(section, "maxSpeed", 20,
        "\n The maximum speed that the ship can go to correct itself." +
        "\n This is relative to the current speed of the leader ship.");
    public IniValueEnum<UpdateFrequency> tickSpeed = new IniValueEnum<UpdateFrequency>(section, "tickSpeed", UpdateFrequency.Update1,
        "\n This is the frequency that the scirpt is running at. If you are" +
        "\n experiencing lag because of this script, try decreasing this value." +
        "\n Update1 : Runs the script every tick" +
        "\n Update10 : Runs the script every 10th tick" +
        "\n Update100 : Runs the script every 100th tick");
    public IniValueBool calculateMissingTicks = new IniValueBool(section, "calculateMissingTicks", true,
        "\n When the tick speed of the leader is lower than the tick speed of" +
        "\n the follower, this workaround can be activated. When this is enabled," +
        "\n the script will \"guess\" what the leader position should be.");
    public IniValueInt maxMissingScriptTicks = new IniValueInt(section, "maxMissingScriptTicks", 100,
        "\n When calculateMissingTicks is enabled, the maximum number of ticks" +
        "\n to estimate before assuming the leader is no longer active." +
        "\n 1 game tick = 1/60 seconds");


    public Settings (IMyProgrammableBlock me)
    {
        Me = me;
    }

    public void Load ()
    {
        if (!string.IsNullOrWhiteSpace(Me.CustomData))
        {
            MyIniParseResult result;
            if (!ini.TryParse(Me.CustomData, out result))
                throw new IniParseException(result.ToString());

            if (ini.ContainsSection(section))
            {
                followerSystemId.Load(ini);
                followerId.Load(ini);
                configs.Load(ini);
                enableCollisionAvoidence.Load(ini);
                cockpitName.Load(ini);
                autoStop.Load(ini);
                autoStartHere.Load(ini);
                maxSpeed.Load(ini);
                tickSpeed.Load(ini);
                calculateMissingTicks.Load(ini);
                maxMissingScriptTicks.Load(ini);
                init = true;
                return;
            }
        }


        SaveAll();
        throw new Exception("\n\nSettings file has been generated in Custom Data.\nThis is NOT an error.\nRecompile the script once you ready.\n\n\n\n\n\n\n\n\n\n\n\n\n\n");
    }

    public void Save ()
    {
        if (!init)
            return;
        MyIniParseResult result;
        if (!ini.TryParse(Me.CustomData, out result))
            throw new IniParseException(result.ToString());
        SaveAll();
    }

    private void SaveAll()
    {
        followerSystemId.Save(ini);
        followerId.Save(ini);
        configs.Save(ini);
        enableCollisionAvoidence.Save(ini);
        cockpitName.Save(ini);
        autoStop.Save(ini);
        autoStartHere.Save(ini);
        maxSpeed.Save(ini);
        tickSpeed.Save(ini);
        calculateMissingTicks.Save(ini);
        maxMissingScriptTicks.Save(ini);
        ini.SetSectionComment(section,
            " Formation System - Follower Script Version 1.2" +
            "\n If you edit this configuration manually, you must recompile the" +
            "\n script afterwards or you could lose the changes.");
        Me.CustomData = ini.ToString();
    }

    public class IniValueConfigs : IniValue<Dictionary<string, Vector3D>>
    {
        public IniValueConfigs (string section, string key, string comment = null) : base(section, key, null, comment)
        {
            value = new Dictionary<string, Vector3D>();
            value ["default"] = new Vector3D(50, 0, 0);
        }

        protected override void Set (MyIni ini)
        {
            StringBuilder sb = new StringBuilder();
            foreach (KeyValuePair<string, Vector3D> kv in value)
            {
                sb.Append(kv.Key);
                sb.Append(' ');
                sb.Append(kv.Value.X);
                sb.Append(' ');
                sb.Append(kv.Value.Y);
                sb.Append(' ');
                sb.Append(kv.Value.Z);
                sb.Append('\n');
            }
            if(value.Count > 1)
                sb.Length--;
            ini.Set(key, sb.ToString());
        }

        protected override bool TryGetValue (MyIniValue storage, out Dictionary<string, Vector3D> value)
        {
            value = new Dictionary<string, Vector3D>();
            List<string> lines = new List<string>();
            storage.GetLines(lines);
            foreach(string l in lines)
            {
                if (string.IsNullOrWhiteSpace(l))
                    continue;
                string [] configValues = l.Split(new [] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
                if (configValues.Length != 4)
                    return false;
                Vector3D offset = new Vector3D();
                if (!double.TryParse(configValues [1], out offset.X))
                    return false;
                if (!double.TryParse(configValues [2], out offset.Y))
                    return false;
                if (!double.TryParse(configValues [3], out offset.Z))
                    return false;
                value[configValues [0]] = offset;
            }
            return value.Count > 0;
        }
    }
}

public class StorageData
{
    private readonly Program prg;
    private readonly StringBuilder sb = new StringBuilder();

    public StorageData(Program prg)
    {
        this.prg = prg;
    }

    private Vector3D offset = new Vector3D();
    public Vector3D Offset
    {
        get
        {
            return offset;
        }
        set
        {
            offset = value;
            if (AutoSave)
                Save();
        }
    }

    private bool isDisabled = false;
    public bool IsDisabled
    {
        get
        {
            return isDisabled;
        }
        set
        {
            if (isDisabled != value)
            {
                isDisabled = value;
                if (AutoSave)
                    Save();
            }
        }
    }

    private string currentConfig = "default";
    public string CurrentConfig
    {
        get
        {
            return currentConfig;
        }
        set
        {
            currentConfig = value;
            if (AutoSave)
                Save();
        }
    }

    public bool AutoSave { get; set; } = true;

    public void Save()
    {
        // isDisabled;currentConfig;x;y;z
        if (isDisabled)
            sb.Append("1;");
        else
            sb.Append("0;");
        sb.Append(currentConfig);
        sb.Append(';');
        sb.Append(offset.X);
        sb.Append(';');
        sb.Append(offset.Y);
        sb.Append(';');
        sb.Append(offset.Z);
        prg.Storage = sb.ToString();
        sb.Clear();
        AutoSave = true;
    }

    public void Load()
    {
        string storage = prg.Storage;
        Settings settings = prg.settings;

        if (string.IsNullOrWhiteSpace(prg.Storage))
        {
            Save();
            if (!settings.configs.Value.ContainsKey(currentConfig))
                currentConfig = settings.configs.Value.First().Key;
            return;
        }

        try
        {
            // Parse Storage values
            string[] args = prg.Storage.Split(';');
            bool loadedIsDisabled = args[0] == "1";
            string loadedCurrentConfig = args[1];
            Vector3D loadedOffset = new Vector3D(
                double.Parse(args[2]),
                double.Parse(args[3]),
                double.Parse(args[4])
                );

            if (settings.configs.Value.ContainsKey(loadedCurrentConfig))
                currentConfig = loadedCurrentConfig;
            else
                currentConfig = settings.configs.Value.First().Key;
            offset = loadedOffset;
            isDisabled = loadedIsDisabled;
        }
        catch (Exception)
        {
            Save();
        }
    }

}


const double thrustP = 3;
const double thrustI = 2;
const double thrustD = 15;
const double thrustDecay = 0.2;
const float minThrust = 1.0000001f;

class ThrusterControl
{
    private List<IMyThrust> thrusters = new List<IMyThrust>();
    IMyShipController rc;

    VectorPID pid;

    public void Reset ()
    {
        foreach (IMyThrust t in thrusters)
            t.ThrustOverride = 0;
    }

    public ThrusterControl (IMyShipController rc, UpdateFrequency tickSpeed, List<IMyThrust> thrusters)
    {
        if (rc == null)
            throw new Exception("Ship controller null.");

        double factor = 1;
        if (tickSpeed == UpdateFrequency.Update10)
            factor = 10;
        else if (tickSpeed == UpdateFrequency.Update100)
            factor = 100;
        double secondsPerTick = (1.0 / 60) * factor;

        pid = new VectorPID(thrustP / factor, thrustI / factor, thrustD / factor, thrustDecay / factor, secondsPerTick);
        this.rc = rc;
        this.thrusters = thrusters;
        Reset();
    }

    public Vector3D ControlPosition (Vector3D targetPosition, Vector3D targetVelocity, double maxSpeed = double.PositiveInfinity)
    {
        return ControlVelocity(targetVelocity + VectorClamp(-pid.Control(rc.GetPosition() - targetPosition), maxSpeed));
    }

    public Vector3D VectorClamp (Vector3D v, double max)
    {
        double len2 = v.LengthSquared();
        if (len2 > max * max)
            v = (v / Math.Sqrt(len2)) * max;
        return v;
    }

    public Vector3D ControlVelocity (Vector3D targetVelocity)
    {
        // Calculate the needed thrust to get to velocity
        Vector3D myVel = rc.GetShipVelocities().LinearVelocity;
        Vector3D deltaV = myVel - targetVelocity;

        if (Vector3D.IsZero(deltaV))
            return Vector3D.Zero;

        Vector3D gravity = rc.GetNaturalGravity();
        return 2 * deltaV + gravity;
    }

    public void ApplyAccel (Vector3D accel)
    {
        if (accel.Equals(Vector3D.Zero, 0.1))
            accel = Vector3D.Zero;

        Vector3D thrust = accel * rc.CalculateShipMass().TotalMass;
        foreach (IMyThrust t in thrusters)
        {
            if (!t.IsFunctional)
                continue;

            float outputThrust = (float)Vector3D.Dot(t.WorldMatrix.Forward, thrust);
            if (outputThrust > 0)
            {
                float outputProportion = MathHelper.Clamp(outputThrust / t.MaxEffectiveThrust, minThrust / t.MaxThrust, 1);
                t.ThrustOverridePercentage = outputProportion;
                thrust -= t.WorldMatrix.Forward * outputProportion * t.MaxEffectiveThrust;
            }
            else
            {
                t.ThrustOverride = minThrust;
            }
        }
    }

}